## useCallback

useCallback을 한번 다뤄보겠다. 위의 개요를 읽어봤다면 이 API또한 성능 최적화를 위한 방법이라는 것을 알아낼 수 있다. useMemo와 차이점을 먼저 알아보자. useMemo는 메모이제이션을 통해서 특정 값을 재사용하는 것이다. useCallback은 메모이제이션을 통해서 특정 함수를 재사용한다는 것이다. 둘의 차이점은 값을 재사용하는 것과 함수를 재사용하는 것의 차이다.

사실 함수를 선언하는 것은 리소스를 많이 차지하는 작업은 아니다. 그렇지만 리렌더링이 될 때마다 새로 만들어지는 것보다 이미 만든 함수를 필요할 때만 사용하는 것은 중요하다. 이런 것들 하나씩 아껴서 빠르고 강력한 UX가 탄생하는 것이다. 자원을 최소한으로 사용하는 것을 항상 목표로 두고 공부를 해보자. 개발자가 계속해서 공부하는 가장 큰 이유이기도 하다.

왜 사용하는지에 대해서는 이미 useMemo에서 충분히 다뤘기에 바로 사용법으로 가보겠다.

### 사용법

일단 간단하게 과거를 되돌아보자. 과거의 코드에 이미 우리는 이벤트 핸들러 함수를 여러번 만들어봤다. 보통 이름은 onRemove 혹은 handleRemove 이런 식으로 함수 이름을 지어줬던 것을 알고 있다. useCallback이 들어갈 부분이 이런식이다.

```js
 const handleRemove = () => {
     // 유저를 전체 유저의 배열에서 지우는 코드.
     setUsers(users.filter(...));
     ...
 }

 const handleRemove = useCallback(() => {
     setUsers(users.filter(...));
 }, [users])
```

코드 작성 예시에서 위의 부분은 우리가 평소에 작성하던 부분이다. 그리고 아래 부분이 useCallback API를 이용해 작성한 부분이다. 사실 뭐 크게 다르다고 볼 순 없다. 그렇지만 꼭 짚고 넘어가야할 부분은 의존성 배열이다. handleRemove라는 함수 안에서 사용되는 props나 상태가 있다면, 꼭 의존성 배열 안에 넣어줘야 한다. 이 작업을 제대로 해주지 않으면 props나 상태가 가장 최신이라고 보장할 수 없는 상황이 발생한다. 이 부분만은 꼭 알고 가자.

일단 useCallback은 여기서 끝이다. 사실 근데 이렇게 바꿔줘도 크게 달라지는 것은 없다. 리렌더링이 되어도 똑같이 만들어지고 최적화가 이루어지지 않는다. 이제 이 부분을 개선하기 위해서 사용해야할 방법이 있다.

### React.memo

아니 분명히 성능 최적화에서 두 가지만 다룬다고 했는데 왜 세 가지냐? 라고 물어볼 수 있지만, 어쩔 수 없다. useCallback 쓰려면 이놈도 필요하다. 그냥 쿨하게 봐라. 그리고 사용하는 방법도 그렇게 어렵지 않다. 코드로 한 번 보자.

```js
import React from 'react';

const User = ({...}) => {
  return (
    <div>
      ...
    </div>
  );
};

export default React.memo(User);
```

일반적으로 우리가 Hook을 이용해서 컴포넌트를 이룬다면 이런 식으로 많이 볼텐데 React.memo를 사용하기 위해서는 그냥 맨 밑에 export 할때 React.memo(컴포넌트)를 넣어주면 된다. useCallback으로 기존 핸들러를 바꿔주고 props로 영향을 받는 컴포넌트들에 저걸 다 추가해주면 된다. 정말 간단하지 않은가? 이게 끝이다. 이렇게 해주면 컴포넌트에서 리렌더링이 필요한 상황에서만 리렌더링을 해준다.

근데 리렌더링이 필요한 상황에서만 사용을 할 수 있다는 말은 곧 리렌더링을 방지해준다고 해석하는 사람도 있을 것 같다. 그렇게 사용하지마라. 이건 내 의견이 아니라 공식 문서가 그랬다. 자세하게는 안 나와있지만 그런 식으로 사용하면 버그가 발생할 수 있다로 정리되어 있다. React.memo는 오직 성능 최적화를 위해서만 사용이 된다. 만약 렌더링을 방지하기 위한 목적이라면 다른 방법을 한 번 찾아보자.

## 정리

원래 커스텀훅이랑 다른 것들도 조금씩 적어보려 했는데 생각보다 길게 나와서 여기까지만 적겠다. 커스텀훅은 따로 정리를해서 올리겠다. 끝내기 전에 마지막으로 정리해보자면 useMemo와 useCallback은 성능 최적화를 위한 API다. 그 중에 중요한 개념인 메모이제이션은 이전에 사용한 값이 렌더링 후에도 변화하지 않았다면 굳이 다시 만들지 않고 이 전에 사용한 값을 사용하겠다는 의미다. 그 중에서 useMemo는 메모이제이션된 값을 반환하고 useCallback은 메모이제이션된 콜백 함수를 반환한다. 여기서 useCallback은 선언만 해준다고 바로 적용이 되는 것이 아니고, React.memo를 같이 사용해야 비로소 성능 최적화를 이룰 수 있다.

주의 사항은 useMemo는 성능 최적화를 이룰 수 있는 무기지만, 그렇다고 바로 사용하지는 말자. 먼저 성능 최적화에 관련된 부분들을 생각하지 말고 만들고 동작이 되는 것을 확인한 후에 성능 최적화 API들을 이용해보자. 바로 사용해서 코드를 작성하는 것 보다는 느리겠지만, 정석이 왜 정석이겠는가? 빠르게 가려다가 더 많이 돌아가버릴지도 모를 일이니 신중하게 코드를 작성하자.

useCallback은 선언한다고 바로 적용되지 않는다. 늘 React.memo를 사용하는 것을 잊지말자. 그리고 의존성 배열을 충분히 관리 해줘야한다. 대충하고 넘어가면 시간만 낭비한 걸지도 모른다. 그리고 React.memo를 렌더링 방지의 목적으로 사용하지 말자. 버그날 수 있다. 여기까지 끝.
