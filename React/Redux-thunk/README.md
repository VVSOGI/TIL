# practice Redux thunk

늘 리덕스를 사용하면서 부족함을 느꼈다. 최근에는 리액트에 다양한 Hooks의 API를 다뤄보면서 어떻게 코드를 작성해야 선언적인 프로그래밍을 십분 활용할 수 있을지 많은 고민을 했다. 코드는 발전해야한다. 독학도 발전하는 길 중에 하나지만 굳이 시니어들의 코드를 보지 않으면서까지 독학할 이유는 없다. 이 코드는 전적으로 벨로퍼트님의 코드를 보면서 작성한 것이다.

이 코드는 선언적이고 코드의 응집도나 함수가 하나의 역할을 하냐고 묻는다면 그렇다고는 말 못하겠다. 우선은 리덕스다. 기초를 다시 쌓는다는 느낌으로 작성된 코드다.

리덕스는 DUCKS 패턴을 이용해서 작성되었다. 덕스 패턴은 액션 상수 액션 생성 함수 리듀서같은 리덕스를 사용하기 위한 보일러 플레이트들을 하나의 파일에서 구현하는 리덕스 방법론이다. 리덕스 관련 코드는 대부분 모듈스 폴더에 모여있다.

그리고 지금은 잘 사용하지 않는다고 들었는데 프레젠테이셔널 컴포넌트라는 방법론을 사용했다. 실제로 UI를 보여주는 컴포넌트와 UI가 보여주는 것들을 준비해서 프롭스로 넘겨주는 컨테이너를 구분해서 리액트를 사용하는 것이다. 지금은 이렇게 구현하지 않는 이유는, 굳이 프롭스로 넘겨줄 이유가 없기 때문이기도 하다.

지금 이 프로젝트는 API를 호출해서 간단한 배열 데이터를 받아오는데, 컨테이너에서 dispatch와 selector를 이용해서 작업을 처리한 후 UI를 보여주는 컴포넌트에 프롭스로 넘겨준다. 현재 커스텀 훅을 만들어서 사용할 수 있기에 이 과정은 불필요할 수 있다.

커스텀 훅을 만들어서 그 안에서 dispatch와 selector를 이용해서 데이터를 받아온 후에 UI를 보여주는 컴포넌트에서 커스텀 훅을 불러와서 사용만 해준다면 컨테이너라는 과정을 생략할 수 있다. 하지만 꽤 훌륭한 방법론이니 한 번 해봤다.

일단 Redux Thunk를 왜 사용하나? thunk는 액션 객체가 아닌 액션 함수를 디스패치 할 수 있다. thunk는 기본적으로 미들웨어다. 미들웨어는 결국 하나의 함수다. 함수를 연달아서 리턴하는 하나의 함수. 그리고 미들웨어는 주어진 액션을 중간에서 여러 가공을 할 수 있게 해준다.

```js
const thunk = (store) => (next) => (action) =>
  typeof action === "function"
    ? action(store.dispatch, store.getState)
    : next(action);
```

실제 thunk의 코드는 위와 유사하다고 한다. 이 미들웨어를 사용하면 함수를 디스패치할 수 있다. 함수를 디스패치 할 때에는, 해당 함수에서 dispatch와 getState를 파라미터로 받아와줘야 한다. 이 함수를 만드는 것이 thunk다.

```js
export const createPromiseThunk = (
  type: string,
  promiseCreator: (props: number) => void
) => {
  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];

  return (param: number | null) =>
    async (dispatch: (item: any) => void, getState: () => void) => {
      dispatch({ type, param });
      try {
        const payload = await promiseCreator(param !== null ? param : 0);
        dispatch({ type: SUCCESS, payload });
      } catch (e) {
        dispatch({ type: ERROR, payload: e, error: true });
      }
    };
};
```

위에 작성된 코드가 thunk를 만드는 과정이라고 볼 수 있는데,

```js
async (dispatch: (item: any) => void, getState: () => void)
```

이 부분이 thunk를 통해 만들어진 부분이라고 보면 된다. 사실 이렇게 안해도 할 수 있는 거 아니냐라고 물어보면 맞다고 말할 수 있다. 근데 이렇게 안하면 비동기 함수를 사용해서 데이터를 불러오고 상태를 리덕스로 저장하려면 코드의 응집성이 낮아진다랄까? 코드도 지저분해지는 경향이 있으니 따로 분류해서 비동기 처리를 한다고 생각하자.

기억해야 할 것은 thunk를 사용함으로써 몇 가지 조건을 구분해서 디스패치를 할 수 있게 됬다. 리덕스는 사용성이 복잡한 편이다. 하지만 최근에는 보일러 플레이트를 따로 만들지 않고도 툴킷을 이용하면 쉽게 리듀서까지 생성할 수 있으니 점점 개선되고 있다고 볼 수 있다.

큰 프로젝트에서 Context Api를 사용하는 것은 위험 부담이 크다. 물론 관련 API들도 많아서 굳이 리덕스만 사용하라고 할 순 없지만 미들웨어를 사용해서 여러가지 기능을 구현할 수 있다는 건 메리트가 아닐 수가 없다. 노력하자.
