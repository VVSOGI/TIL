# 운영체제

다양한 프로그램들은 **입출력 장치의 통제와 같은 공통적인 연산**을 필요로 한다. 여기에 자원을 제어하고 할당하는 기능을 하나의 소프트웨어로 통합한 것이 운영체제이다.

⇒ 연산에 필요한 자원을 제어하고 할당해주는 운영체제.

컴퓨터 시스템은 대개 네 가지 구성요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있다.

**하드웨어**는 중앙처리장치(CPU), 메모리 및 입출력(I/O) 장치로 구성되어 기본 계산용 자원을 제공한다.

**응용 프로그램**인 워드프로세서, 스프레드시트, 컴파일러, 그리고 웹 브라우저 등은 사용자의 계산 문제를 해결하기 위해 이들 자원이 어떻게 사용될 지를 정의한다.

**운영체제**는 하드웨어를 제어하고 다양한 사용자를 위해 다양한 응용 프로그램간의 하드웨어 사용을 조정한다.

## 컴퓨터 시스템의 동작

현대의 범용 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스를 통해 연결된 **여러 개의 장치 제어기와 하나 이상의 CPU**로 구성되어 있다.

CPU와 장치 제어기는 메모리 사이클을 얻기 위해 **경쟁하면서 병행 실행**될 수 있다. **공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 제어기가 제공**되며, 그 기능은 **메모리 접근을 동기화**시키는 일이다.

⇒ 아무래도 **하드웨어를 제어하는 것은 운영체제의 역할**이니 위에 메모리 접근을 동기화 시키는 일은 **운영체제의 일이라고 생각이 된다.**

컴퓨터가 전원이 켜지거나 리부팅할 때 실행할 **초기 프로그램(또는 부트스트랩 프로그램)** 을 가지고 있어야 한다. 이 초기 프로그램은 매우 **단순한 형태**를 가지는 것이 일반적이다. 전형적으로 이것을 보통 **펌웨어**라고 알려져 있는 **컴퓨터 내의 읽기 전용 메모리(ROM, Read-Only Memory)나 EEPROM**에 저장된다.

⇒ ROM은 비휘발성 메모리. 전원이 꺼진다해서 사라지는 영역이 아니다.

이 **초기 프로그램(또는 부트스트랩 프로그램)**은 **CPU 레지스터**로부터 장치 제어기, 메모리 내용등을 포함한 시스템의 모든 면을 **초기화**한다.

이러한 목적을 달성하기 위해서 부트스트랩 프로그램은 **운영체제의 커널**을 찾아 **메모리에 적재**해야 한다.

⇒ 현재 상황

1.  부트스트랩 프로그램이 운영체제의 커널을 찾아 메모리에 적재
2.  CPU 레지스터로부터 장치 제어기, 메모리 내용등을 포함한 모든 면을 초기화.

그런 다음에 "init"같은 첫번째 프로세스를 실행 후 **이벤트 발생까지 대기**한다.

이벤트가 발생하면 하드웨어나 또는 소프트웨어로부터 발생한 **인터럽트(interrupt)**에 의해 신호가 보내어진다. **하드웨어는** 어느 순간이든 시스템 버스를 통해 **CPU에 신호를 보내 인터럽트**를 발생시킬 수 있다. **소프트웨어는** **시스템 호출**이라 불리는 특별한 연산을 실행하여 인터럽트를 발생시킬 수 있다.

**CPU가 인터럽트되면**, **CPU**는 하던 일을 중단하고, **즉시 고정된 위치로 실행을 옮긴다.** 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이 실행된다. 인터럽트 서비스 루틴의 **실행이 완료**되면, **CPU는 인터럽트 되었던 연산을 재개**한다.

⇒ 현재 상황

1.  부트스트랩 프로그램이 **운영체제의 커널을 찾아 메모리에 적재**
2.  CPU 레지스터로부터 장치 제어기, 메모리 내용등을 포함한 **모든 면을 초기화.**
3.  "init"같은 첫번째 프로세스를 **실행** 후 이벤트 발생까지 **대기**.
4.  이벤트가 발생하면 **하드웨어** || **소프트웨어로부터** 발생한 **인터럽트에 의해 신호가 보내짐.**
5.  CPU가 **인터럽트되면** CPU는 하던 동작을 멈추고 **즉시 고정된 위치로 실행을 옮김.**
6.  인터럽트 서비스 루틴의 **실행이 완료**되면, **CPU는 멈췄던 동작의 연산을 재개**

**인터럽트 구조는** 인터럽트된 명령의 주소를 **반드시 저장**해야 한다. 과거의 많은 설계는 고정된 위치에 인터럽트 주소를 저장하거나 장치 번호에 의해 색인되는 위치에 저장하였지만, **최근의 구조들은 시스템 스택에 복귀 주소를 저장한다.**

![https://media.vlpt.us/images/vvsogi/post/0ecf13ad-d1bd-45d2-b64a-e4647ac31123/img1.daumcdn.jpg](https://media.vlpt.us/images/vvsogi/post/0ecf13ad-d1bd-45d2-b64a-e4647ac31123/img1.daumcdn.jpg)

## 저장장치 구조

**CPU**는 **오직 메모리로부터 명령을 적재**할 수 있으며, **모두 메모리에 저장되어야 한다.** 범용 컴퓨터는 대부분의 프로그램을 **읽기-쓰기 가능한 메모리**인 **주 메모리(Random-Access Memory, RAM)**에서 실행시킨다. 또한, 컴퓨터는 다른 형태의 메모리로 **Read-Only memory(ROM)을 사용하는데 ROM은 갱신될 수 없기 때문에 오직 정적인 프로그램만이 저장**된다. (예를 들어, 스마트폰은 공장 설치 프로그램을 저장하는 데 EEPROM을 사용한다.)

상호작용은 특정 메모리 주소들에 대한 일련의 **적재(load)** 또는 **저장(store) 명령**을 통하여 이루어진다.

1. **적재** 명령은 **주 메모리**로부터 **CPU** 내부의 **레지스터**로 한 워드를 옮기는 것
2. **저장** 명령은 **레지스터**의 내용을 **주 메모리**로 옮긴다.

**폰 노이만 구조 시스템**에서 실행되는 **전형적인 명령-실행 사이클**은 먼저 **메모리로부터 명령을 인출**해 그 명령을 **명령 레지스터(instruction register)에 저장**한다. 이어서 **명령을 해독**하고, 명령은 **메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다.** 피연산자에 대해 명령을 실행한 후에 **결과가 메모리에 다시 저장될 수 있다.**

이상적으로는, 프로그램과 데이터가 주 메모리에 **영구히 존재하기를 원한다.** **그러나** 이는 다음 **두 가지 이유** 때문에 불가능하다.

```
1. 주 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
2. 주 메모리는 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다.
```

## 입출력 구조(I/O Structure)

**저장장치는** 컴퓨터 내의 여러 형태의 **입출력장치** 중 하나이다. 시스템의 신뢰성과 성능에 미치는 중요성 그리고 장치들의 다양한 특징 때문에 **운영체제 코드의 많은 부분들이 입출력을 관리하는 데 할애**된다. 다음으로 입출력에 대한 전체적인 모습을 살펴보겠다.

**범용 컴퓨터 시스템**은 공통 버스에 의해 연결된 여러 개의 장치 제어기와 CPU들로 구성되어있다. 각 장치 제어기가 특정 타입의 장치를 담당한다. **장치 제어기**는 약간의 로컬 버퍼 저장장치와 특수 목적용 레지스터 집합을 유지한다. 장치제어기는 자신이 제어하는 주변장치와 자신의 **로컬 버퍼 저장장치 사이의 데이터 전송을 담당한다.**

통상적으로 **운영체제**는 각 장치 제어기마다 **디바이스 드라이버**를 가지고 있다. 이 디바이스 드라이버는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분들에게 장치에 대한 일관된 인터페이스를 제공한다.

⇒ 운영체제는 장치 제어기를 가지고 있다.

⇒ 이유는 제어하는 주변장치와 로컬 버퍼 저장장치 사이의 데이터 전송을 담당 및 관리하기 위해서.

일단 데이터 **전송이 완료**되면, 장치 제어기는 자신이 연산을 완료했음을 **인터럽트를 이용하여 디바이스 드라이버에게 통보**한다. 그러면 디바이스 드라이버는 **제어**를 운영체제에게 **반환**하고 이때 입력 완료인 경우에는 데이터 또는 데이터에 대한 포인터를 같이 반환할 수 있다. 다른 동작에 대해서는 디바이스 드라이버는 상태 정보를 반환한다.

이 인터럽트 구동 방식은 입출력은 **적은 양의 데이터를 전송하는 데에는 문제가 없으나** 디스크 입출력과 같은 **대량의 데이터**를 전송하는 데에는 **높은 오버헤드**를 초래한다.

이 문제를 해결하기 위해서 **직접 메모리 접근(Direct Memory Access, DMA)** 장치가 사용된다. 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다. 속도가 느린 장치처럼 한 바이트마다 인터럽트가 발생하는 것이 아니라 블록 전송이 완료될 때마다 인터럽트가 발생한다. 장치 제어기가 전송 작업을 실행하고 있는 동안 CPU는 다른 작업을 실행할 수 있어서 효율성이 높아진다.

⇒ 적은 양의 데이터를 전송하는 것에는 문제가 없으나, **데이터의 용량이 커졌을 때**, CPU가 바이트마다 인터럽트를 전송하는 것은 비효율적이다. 따라서 **데이터 블록 전체를 한번에 전송하는 DMA방식이 고안**되었고, DMA 방식을 이용하면 **CPU의 개입이 적어도 I/O 와는 없어지므로 CPU는 다른 많은 일들을 처리할 수 있게 되었다.** 이 방식은 꽤나 효과적이다.

![https://media.vlpt.us/images/vvsogi/post/259fd7e9-e632-4175-84cd-7d9963884ba8/img-1.jpg](https://media.vlpt.us/images/vvsogi/post/259fd7e9-e632-4175-84cd-7d9963884ba8/img-1.jpg)

DMA를 사용하지 않은 Processer

![https://media.vlpt.us/images/vvsogi/post/8b468eee-c15d-4c2f-9e58-f382ee3e3048/img.jpg](https://media.vlpt.us/images/vvsogi/post/8b468eee-c15d-4c2f-9e58-f382ee3e3048/img.jpg)

DMA를 사용한 Processer
