# 캔버스

이 글은 김종민 디벨로퍼님의 material-interaction을 세부적으로 파헤치면서 canvas의 엘리먼트들을 어떻게 Dom요소처럼 다룰 수 있는지와 여러가지 이펙트가 어떻게 구현된 것인지 공부하는 목적으로 작성한다.

일단, 김종민 디벨로퍼님이 작성하신 코드는 약 6년전에 작성된 코드로 2016년의 자바스크립트 코드를 보고있다. 변수부터 var를 사용하는 시기라고 보면 된다. 그리고 Class를 사용하는 것이 아닌 함수와 오브젝트 안에 기능들을 구현하고 프로토타입을 이용하는 등 나같은 초보에겐 굉장히 어려운 코드라고 볼 수 있다. 하나하나 파헤쳐보기 전에 적어도 알아가고 싶은 한 가지를 작성하겠다.

- 1. canvas로 그린 element를 클릭할 때 반응하게끔 하는 방법은 무엇일까

사실 더 궁금한 건 많지만 내가 과연 김종민 디벨로퍼님의 코드를 다 이해하고 받아들일 수 있을까? 라는 생각에 단 한 가지라도 제대로 알고 가자는 의미로 목표는 한 가지로 정했다. 나중에 실력이 더 쌓이면 이해할 부분들이 있을 것이다.

우선 이 코드들은 상당히 유기적으로 얽혀있는 모습이다. 그림처럼 코드가 어디로 연결이 되는 지 생각을 하면서 하던 직접 그림을 그리면서 코드의 길을 읽던 해야한다. import export가 쓰이던 시절의 코드가 아니라서 유전자 레벨에 각인된 프로토타입도 자세히 파헤치겠다.

시작은 Address.init으로 시작한다. 어떻게 되었건 시작은 Address가 될 것이다. 김종민 디벨로퍼님의 코드의 특징으로 사용되어야 할 변수들이 상단에 우선적으로 배치되어있다. 할당 되어있는 변수도 있지만 그렇지 않은 변수가 더 많다. Address.init의 첫 번째 부분에는 돔 요소를 변수에 할당하는 것으로 시작한다. 그리고 아마도 익스플로러 사용자가 페이지를 들어갔을 때 작동이 안되는 부분들이 있기에, 크롬으로 연결시켜주는 부분이 있다.

이어서 StageController.init({minw:320}); 를 실행시키는데, 클로저의 사용이 보인다. 클로저는 뭐랄까 변수를 한 단계 밖에서 실행할 수 있게끔? 해주는 그런 방법인데, 클로저를 사용하는 것을 처음 봤기도 하고 솔직히 어려운 부분이라 이해하기가 쉽지 않았다. 어쨋든 StageController는 객체를 리턴하는 함수로 \_Public이라는 객체를 리턴한다.

이게 상당히 기초적인 부분도 공부가 되는 것이 나는 클래스라는 Syntactic sugar가 나온 이후로는 클래스를 사용하는 것이 익숙한 사람이다. 하지만 클래스가 나오기 이전에는 어떻게 사용하였는 지 미숙하게 알고있다가 이렇게 직접 코드로 마주하게 되니까 정말 놀랍다. 어쨋든 다시 이어서 하자면, \_Public이라는 객체를 리턴한다고 말했는데, 그 전에 init, addResize, removeResize, onResize라는 이름의 네 가지 함수가 \_Public 객체에 할당된다. 그래서 Address에서 StageController.init()이라는 메소드를 사용한 것이다.

어쨋든 StageController는 말 그대로 웹이나 모바일에서 사이즈가 변경될 때 반응하게끔 해주는 초기 설정이라고 볼 수 있다. minw는 화면이 어지간히 작아져도 320의 사이즈를 유지할 수 있게끔 설정을 한 것이다.

그 이후로 Address에서
Index.init($root, $indexCon);
About.init($root);
Sub.init($root);
Close.init($root);
를 실행시킨다.

여기부터 유기적으로 굉장히 딥하게 연결이 되어있는데, 우선 기본적으로 김종민 디벨로퍼님은 html을 직접 작성하는 것이 아닌 자바스크립트를 통해서 만든다. Index.init은 필요한 html 요소들을 만들어 준다고 보면 된다. 이 과정에서 UI.item()을 생성시키는데, 이 부분도 동일하게 필요한 html 요소들을 제공해주고 각 요소에 들어갈 canvas적 요소들을 구분하기 위한 curClass를 할당해준다. 최초 로딩이 끝났을 때, 구분된 각 화면의 요소들의 css요소를 꾸며주기 위해서 items.init() 또한 실행시킨다.

ex ) this.curClass.init(this.con);

그리고 각 구분된 화면마다 addEventListener click을 적용시키는데, 구분된 화면을 클릭하면 화면의 CSS적 요소들이 변경되는 것을 의미한다.

이제 About.init()을 보겠다. 일단 어바웃은 로딩후 랜딩된 페이지의 우측 상단에 위치한 포스트 잇 같은 element의 부분에 적용되는 효과들의 집합이라고 보면 될 것 같다. 포스트 잇을 클릭하면 화면이 전환되는데 필요한 html 요소들을 만드는 것이 About의 최초 코드다. 그리고 각 요소에 필요한 addEventListener를 설정해준다. About은 그나마 이해하기 쉬운 부분이다.

Sub.init()은 본격적으로 구분된 화면의 원하는 부분을 클릭했을 때 나타나는 캔버스를 구분하기 위한 부분이다. 시작은 늘 그렇듯 canvas를 createElement 해주고 id 값을 설정해준다. 그리고

Surface.init($container, $canvas, _ctx, $guide, _ctxGuide);
Action.init($container, $canvas, _ctx, $guide, _ctxGuide);
Motion.init($container, $canvas, _ctx, $guide, _ctxGuide);
Change.init($container, $canvas, _ctx, $guide, _ctxGuide);
Interaction.init($container, $canvas, \_ctx, $guide, \_ctxGuide);

를 각각 실행시킨다. 실제로 어떤 화면이든 전환된 이후에 확인해보면 모든 캔버스와 가이드 캔버스는 동일한 아이디 값을 가지고 있다.

Surface.init($container, $canvas, \_ctx, $guide, \_ctxGuide); 부터 한 번 보자. 아마 저 5개가 거의 비슷할 것이지만, 우선 Surface 자체적으로 만든 변수에 init() 안에 들어가는 매개 변수들을 할당해준다. 이렇게 하는 이유는 아마 원본의 매개 변수의 손상을 줄이기 위함이 아닐까 라는 생각을 해본다.

이렇게 해준 이후로 이제 각 화면의 컨셉에 맞춰서 만들어둔 변수에 그려줄 아이템들을 할당한다.

\_ball = new UI.ball(0, 0, \_speed);
\_box = new UI.wall();

surface는 메인 화면에서 가장 첫 번째 구분 화면으로 네모난 상자와 통통 튀어다니는 공이 있다. 상자는 마우스로 움직일 수 있고 사이즈를 변화시킬 수도 있다. 공은 화면 가장자리와 상자의 가장자리에 부딪히면 반대 방향으로 튀어나간다.

new UI.ball과 wall은 그 컨셉에 맞춰서 아이템을 생성해주는 것이라고 보면 된다. 더 자세하게 들어가면 UI에 ball이나 wall은 객체로써 다양한 함수들이 할당되어 있다. 바로 한 단락 위에 글에서 공이 튀어다니고 상자를 움직일 수 있게끔 해주는 함수는 아쉽게도 ball이나 wall에 바로 작성되어있지 않다.
~~ball은 actionBall이라는 객체의 특정 함수를 실행시켜야 움직이고 wall은 windowBox라는 특정 객체의 함수를 실행시켜줘야 비로소 움직인다고 볼 수 있다. 그렇다면 Surface.init()은 결론적으로 그저 최초 위치를 정해준다 정도로 생각하고 넘어가면 좋을 것 같다.~~

다시 보니까 아닌 것 같기도 하다.

어쨋든 따로 정리를 안한 아래의 네 가지 경우도 비슷한 경우다.

Action.init($container, $canvas, _ctx, $guide, _ctxGuide);
Motion.init($container, $canvas, _ctx, $guide, _ctxGuide);
Change.init($container, $canvas, _ctx, $guide, _ctxGuide);
Interaction.init($container, $canvas, \_ctx, $guide, \_ctxGuide);

다시 최초 Address로 돌아와서 Close.init()을 한 번 보겠다. 우선 클로즈는 구분된 화면을 클릭한 후 캔버스로 전환된 뒤에 우측 하단에 위치한 닫기 버튼이다. 어바웃과 마찬가지로 간단한 부분이다. 필요한 html 요소에 클릭 이벤트를 걸어주는 정도로만 이해하고 넘어가자.

init()의 거의 모든 부분들을 내 나름대로 해석했다. 이제 마지막으로 조건문으로 적혀있는 CMDetect라는 부분을 확인해보면 된다. 처음엔 CMDetect라는 라이브러리가 있는 줄 알았는데 그런건 아니고 김종민 디벨로퍼님이 만든 파일이다. 음 대체적으로 웹과 모바일을 구분하기 위함이라고 생각하면 좋을 것같다. CMDetect.isTouch라고 작성되어 있다면 모바일이고 CMDetect.isMouse이면 웹이라고 보면 된다.

안의 내용물을 보면 window.document에 이벤트를 걸어두는 코드를 확인할 수 있는데 음... 뭐랄까 솔직히 잘 모르겠다. 화면 전체적으로 클릭이 안되는 부분이 없는 것을 의도해서 document 전체에 이벤트를 걸어놓은 것일까? 이게 잘 모르겠는게 이벤트로 걸려있는 함수가 제대로 잘 작동하고 있는 것인지 잘 모르겠다. 내가 확인 했을 때는 작동을 안 하고 있는 것 같은데 아마 다른 부분에서 사용하려고 만들어놓은 것 같기도하고 솔직히 여기는 잘 모르겠으니 넘기겠다.
