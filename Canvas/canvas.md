# 캔버스

이 글은 김종민 디벨로퍼님의 material-interaction을 세부적으로 파헤치면서 canvas의 엘리먼트들을 어떻게 Dom요소처럼 다룰 수 있는지와 여러가지 이펙트가 어떻게 구현된 것인지 공부하는 목적으로 작성한다.

일단, 김종민 디벨로퍼님이 작성하신 코드는 약 6년전에 작성된 코드로 2016년의 자바스크립트 코드를 보고있다. 변수부터 var를 사용하는 시기라고 보면 된다. 그리고 Class를 사용하는 것이 아닌 함수와 오브젝트 안에 기능들을 구현하고 프로토타입을 이용하는 등 나같은 초보에겐 굉장히 어려운 코드라고 볼 수 있다. 하나하나 파헤쳐보기 전에 적어도 알아가고 싶은 한 가지를 작성하겠다.

- 1. canvas로 그린 element를 클릭할 때 반응하게끔 하는 방법은 무엇일까

사실 더 궁금한 건 많지만 내가 과연 김종민 디벨로퍼님의 코드를 다 이해하고 받아들일 수 있을까? 라는 생각에 단 한 가지라도 제대로 알고 가자는 의미로 목표는 한 가지로 정했다. 나중에 실력이 더 쌓이면 이해할 부분들이 있을 것이다.

우선 이 코드들은 상당히 유기적으로 얽혀있는 모습이다. 그림처럼 코드가 어디로 연결이 되는 지 생각을 하면서 하던 직접 그림을 그리면서 코드의 길을 읽던 해야한다. import export가 쓰이던 시절의 코드가 아니라서 유전자 레벨에 각인된 프로토타입도 자세히 파헤치겠다.

시작은 Address.init으로 시작한다. 어떻게 되었건 시작은 Address가 될 것이다. 김종민 디벨로퍼님의 코드의 특징으로 사용되어야 할 변수들이 상단에 우선적으로 배치되어있다. 할당 되어있는 변수도 있지만 그렇지 않은 변수가 더 많다. Address.init의 첫 번째 부분에는 돔 요소를 변수에 할당하는 것으로 시작한다. 그리고 아마도 익스플로러 사용자가 페이지를 들어갔을 때 작동이 안되는 부분들이 있기에, 크롬으로 연결시켜주는 부분이 있다.

이어서 StageController.init({minw:320}); 를 실행시키는데, 클로저의 사용이 보인다. 클로저는 뭐랄까 변수를 한 단계 밖에서 실행할 수 있게끔? 해주는 그런 방법인데, 클로저를 사용하는 것을 처음 봤기도 하고 솔직히 어려운 부분이라 이해하기가 쉽지 않았다. 어쨋든 StageController는 객체를 리턴하는 함수로 \_Public이라는 객체를 리턴한다.

이게 상당히 기초적인 부분도 공부가 되는 것이 나는 클래스라는 Syntactic sugar가 나온 이후로는 클래스를 사용하는 것이 익숙한 사람이다. 하지만 클래스가 나오기 이전에는 어떻게 사용하였는 지 미숙하게 알고있다가 이렇게 직접 코드로 마주하게 되니까 정말 놀랍다. 어쨋든 다시 이어서 하자면, \_Public이라는 객체를 리턴한다고 말했는데, 그 전에 init, addResize, removeResize, onResize라는 이름의 네 가지 함수가 \_Public 객체에 할당된다. 그래서 Address에서 StageController.init()이라는 메소드를 사용한 것이다.

어쨋든 StageController는 말 그대로 웹이나 모바일에서 사이즈가 변경될 때 반응하게끔 해주는 초기 설정이라고 볼 수 있다. minw는 화면이 어지간히 작아져도 320의 사이즈를 유지할 수 있게끔 설정을 한 것이다.

그 이후로 Address에서
Index.init($root, $indexCon);
About.init($root);
Sub.init($root);
Close.init($root);
를 실행시킨다.

여기부터 유기적으로 굉장히 딥하게 연결이 되어있는데, 우선 기본적으로 김종민 디벨로퍼님은 html을 직접 작성하는 것이 아닌 자바스크립트를 통해서 만든다. Index.init은 필요한 html 요소들을 만들어 준다고 보면 된다. 이 과정에서 UI.item()을 생성시키는데, 이 부분도 동일하게 필요한 html 요소들을 제공해주고 각 요소에 들어갈 canvas적 요소들을 구분하기 위한 curClass를 할당해준다. 최초 로딩이 끝났을 때, 구분된 각 화면의 요소들의 css요소를 꾸며주기 위해서 items.init() 또한 실행시킨다.

ex ) this.curClass.init(this.con);

그리고 각 구분된 화면마다 addEventListener click을 적용시키는데, 구분된 화면을 클릭하면 화면의 CSS적 요소들이 변경되는 것을 의미한다.

이제 About.init()을 보겠다. 일단 어바웃은 로딩후 랜딩된 페이지의 우측 상단에 위치한 포스트 잇 같은 element의 부분에 적용되는 효과들의 집합이라고 보면 될 것 같다. 포스트 잇을 클릭하면 화면이 전환되는데 필요한 html 요소들을 만드는 것이 About의 최초 코드다. 그리고 각 요소에 필요한 addEventListener를 설정해준다. About은 그나마 이해하기 쉬운 부분이다.

Sub.init()은 본격적으로 구분된 화면의 원하는 부분을 클릭했을 때 나타나는 캔버스를 구분하기 위한 부분이다. 시작은 늘 그렇듯 canvas를 createElement 해주고 id 값을 설정해준다. 그리고

Surface.init($container, $canvas, _ctx, $guide, _ctxGuide);
Action.init($container, $canvas, _ctx, $guide, _ctxGuide);
Motion.init($container, $canvas, _ctx, $guide, _ctxGuide);
Change.init($container, $canvas, _ctx, $guide, _ctxGuide);
Interaction.init($container, $canvas, \_ctx, $guide, \_ctxGuide);

를 각각 실행시킨다. 실제로 어떤 화면이든 전환된 이후에 확인해보면 모든 캔버스와 가이드 캔버스는 동일한 아이디 값을 가지고 있다.

Surface.init($container, $canvas, \_ctx, $guide, \_ctxGuide); 부터 한 번 보자. 아마 저 5개가 거의 비슷할 것이지만, 우선 Surface 자체적으로 만든 변수에 init() 안에 들어가는 매개 변수들을 할당해준다. 이렇게 하는 이유는 아마 원본의 매개 변수의 손상을 줄이기 위함이 아닐까 라는 생각을 해본다.

이렇게 해준 이후로 이제 각 화면의 컨셉에 맞춰서 만들어둔 변수에 그려줄 아이템들을 할당한다.

\_ball = new UI.ball(0, 0, \_speed);
\_box = new UI.wall();

surface는 메인 화면에서 가장 첫 번째 구분 화면으로 네모난 상자와 통통 튀어다니는 공이 있다. 상자는 마우스로 움직일 수 있고 사이즈를 변화시킬 수도 있다. 공은 화면 가장자리와 상자의 가장자리에 부딪히면 반대 방향으로 튀어나간다.

new UI.ball과 wall은 그 컨셉에 맞춰서 아이템을 생성해주는 것이라고 보면 된다. 더 자세하게 들어가면 UI에 ball이나 wall은 객체로써 다양한 함수들이 할당되어 있다. 바로 한 단락 위에 글에서 공이 튀어다니고 상자를 움직일 수 있게끔 해주는 함수는 아쉽게도 ball이나 wall에 바로 작성되어있지 않다.
~~ball은 actionBall이라는 객체의 특정 함수를 실행시켜야 움직이고 wall은 windowBox라는 특정 객체의 함수를 실행시켜줘야 비로소 움직인다고 볼 수 있다. 그렇다면 Surface.init()은 결론적으로 그저 최초 위치를 정해준다 정도로 생각하고 넘어가면 좋을 것 같다.~~

다시 보니까 아닌 것 같기도 하다.

어쨋든 따로 정리를 안한 아래의 네 가지 경우도 비슷한 경우다.

Action.init($container, $canvas, _ctx, $guide, _ctxGuide);
Motion.init($container, $canvas, _ctx, $guide, _ctxGuide);
Change.init($container, $canvas, _ctx, $guide, _ctxGuide);
Interaction.init($container, $canvas, \_ctx, $guide, \_ctxGuide);

다시 최초 Address로 돌아와서 Close.init()을 한 번 보겠다. 우선 클로즈는 구분된 화면을 클릭한 후 캔버스로 전환된 뒤에 우측 하단에 위치한 닫기 버튼이다. 어바웃과 마찬가지로 간단한 부분이다. 필요한 html 요소에 클릭 이벤트를 걸어주는 정도로만 이해하고 넘어가자.

init()의 거의 모든 부분들을 내 나름대로 해석했다. 이제 마지막으로 조건문으로 적혀있는 CMDetect라는 부분을 확인해보면 된다. 처음엔 CMDetect라는 라이브러리가 있는 줄 알았는데 그런건 아니고 김종민 디벨로퍼님이 만든 파일이다. 음 대체적으로 웹과 모바일을 구분하기 위함이라고 생각하면 좋을 것같다. CMDetect.isTouch라고 작성되어 있다면 모바일이고 CMDetect.isMouse이면 웹이라고 보면 된다.

안의 내용물을 보면 window.document에 이벤트를 걸어두는 코드를 확인할 수 있는데 음... 뭐랄까 솔직히 잘 모르겠다. 화면 전체적으로 클릭이 안되는 부분이 없는 것을 의도해서 document 전체에 이벤트를 걸어놓은 것일까? 이게 잘 모르겠는게 이벤트로 걸려있는 함수가 제대로 잘 작동하고 있는 것인지 잘 모르겠다. 내가 확인 했을 때는 작동을 안 하고 있는 것 같은데 아마 다른 부분에서 사용하려고 만들어놓은 것 같기도하고 솔직히 여기는 잘 모르겠으니 넘기겠다.

### 구분된 화면 클릭 이벤트

모든 화면의 구분된 부분은 클릭 이벤트가 걸려있다. UI 파일 67번째 코드에서 그 부분을 확인할 수 있는데, 화면의 특정 구간을 클릭하면 해당하는 화면에 있는 data-id라는 속성을 받아오며 곧장 Address.goSub(id)로 넘어간다. Address의 goSub이 실행되면 브라우저가 아 무언가 클릭했구나 라는 것을 인식하고 다른 부분을 클릭한다해도 반응이 없게끔 설정해준다. 이후에 About.hidePage()를 실행시켜서 각 구간을 꾸며주는 컴포넌트들을 자연스럽게 화면에서 숨겨준다. 마지막으로 index.goSub(id)를 실행시킨다.

index.goSub()에서는 화면 전환의 요소들이 많다. 각 구분된 화면의 다섯 가지 컴포넌트들이 클릭이 된 경우와 아닌 경우로 나뉘어서 다르게 반응하는 overFn()을 실행시키고 화면 전환의 자연스러움을 유지하기 위한 \_pos가 있다. 이 후에는 GSAP 라이브러리와 연동해서 delaySub() 이라는 함수를 실행시키는데, 이 함수는 클릭이 되었을 때 클릭된 구간 컴포넌트를 제외한 다른 부분들의 배경이 어두워지는 느낌을 내기 위함과 동시에 다른 화면으로 전환되기 위한 절차라고 볼 수 있다.

중요한 것은 배경화면의 색상이다. 배경화면의 색상이 바뀌는 화면과 일치해야 유저가 부자연스러움을 눈치 채지 못한다. delaySub안에는 다시한번 GSAP 라이브러리와 연동해서 라이브러리 함수가 끝났을 때 index.endSub()을 실행시키는데, 약 1초의 시간이 걸린다. 아까 배경화면의 색상을 맞추기 위해서는 이 1초의 시간동안 자연스럽게 화면이 전환된다는 UX를 확실하게 표현하고, 화면의 색상을 그려주는 draw() 함수를 실행시킨다. 이 draw 함수는 1초동안 실행되지 않고, 화면이 전환되는 이벤트가 끝나고나서야 실행된다. 서순을 설명하자면 goSub => delaySub => 1초 => endSub => draw 로 진행된다.

빠르게 draw로 화면을 그려준 후에 endSub은 이어서 다음 캔버스를 준비한다. 이 캔버스에는 김종민 디벨로퍼님이 준비한 캔버스 애니메이션이 준비되어있다. 캔버스를 $root에 appendChild 해주고 선택한 것이 어떤 캔버스인지를 switch를 통해서 가려준 후에 비로소 현재 선택된 화면의 캔버스의 .ready 메소드를 실행시켜서 필수적인 것들을 예를들어 StageController에서 리사이즈 이벤트를 다시한번 걸어주는 것들을 진행한다. 리사이즈 이벤트를 다시 걸어주는 이유는 지금 준비하고 있는 캔버스 이전에 남아있던 잔재들을 삭제하기도 하고 새로운 화면에서도 화면이 작아지거나 커질때 반응을 해야하기 때문이다.

그리고 이 과정에서 각 컨셉에 있는 아이템들의 위치를 설정한다. 예를 들어 메인 화면의 왼쪽에 있는 공이 튀어다니고 상자의 크기를 유동적으로 설정하는 컨셉인 Surface에서는 최초에 상자를 가운데에 정해놓은 크기로 위치시켜놓고, 공은 랜덤하게 배치하게 한다. 중요한 것은 상자의 위치인데, 상자는 절대적으로 설정해놓은 자리에 생성된다. 그 이유는 유저가 사용하기 전에 튜토리얼처럼 어떤 컨셉인지 알려주는 가이드라인이 있는데, 가이드라인의 위치와 상자의 위치가 틀어지면 안되기 때문이다.

ready() 함수가 끝이나면 다시한번 GSAP 라이브러리를 이용해서 Sub.delayShow 메소드를 delayed Call을 해준다. 이 함수는 선택된 화면의 캔버스를 본격적으로 보여주는 show()를 실행시켜주는데, 0.5초 뒤에 endShow()를 실행시킨다. endShow는 화면 우측하단의 되돌아가기 버튼이나 메인 화면으로 나갔다가 다시 들어오면 가이드가 나오지 않는다던가 Address로 돌아가서 화면이 클릭이 가능한 상태로 변경을 해주는 설정을 해준다.

화면 전환은 아무래도 이정도로 정리가 가능할 것 같다. 사용됬던 함수들이 계속해서 재사용되기 때문에 한번만 잘 알아가면 된다. 재사용한 코드를 작성하는 것이 무엇인지 조금은 알게된 것 같다. 김종민 디벨로퍼님은 한번 작성한 코드로 5가지의 화면을 구현하신 것이다. 정말 배울게 많은 코드인 것 같다. 프로의 코드를 이렇게 대놓고 볼 수 있는 세상인 것에 정말 정말 감사하다!

다음은 이제 각 화면을 구성하는 애니메이션들이 어떤 방식으로 동작하는 지 확인을 해보려 한다.
