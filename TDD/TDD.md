# TDD (Test Driven Development)

테스트 주도적 개발 방법론, 간단하게 보면 테스트를 먼저 작성한 후에 실제 코드를 작성한다. 그래서 코드 작성 시간도 이론상 두 배 정도 늘어난다. TDD의 실행 원칙은 세 가지다. 먼저 테스트를 한 후에 실패한다. 실패한 코드를 통과시킨다. 그리고 행동의 변화가 일어나지 않게끔 리팩토링한다. 이렇게 하면 자연스럽게 클린 코드가 작성이 된다. 여기서 말하는 클린 코드는 코드가 얼마나 깔끔하게 잘 작성되어 있고 응집성이 높은 지를 확인하기 보다는 의존성이 낮고 우리 제품이 원하는 행동을 하는 것에 있어서 잘 작동하는 지를 확인하는 것을 의미한다고 볼 수 있다.

## 왜 TDD인가?

TDD를 사용하면 코드 작성 시간이 늘어난다. 사실 이 늘어난 시간은 미래의 고통을 현재로 가져온 것에 불과하다. TDD를 사용한 코드와 사용하지 않은 코드에 기능 추가를 한다고 생각해보자. 사용하지 않은 코드에 기능을 추가할 때 실력있는 개발자라면 그렇게 어렵지는 않을 것이지만, 아무리 실력있어도 의존성이 연결된 코드들에 어떤 사이드 이펙트가 발생하는 지 모두 파악할 수는 없다. 의문의 부작용이 생겨버린다면 그것을 고치려고 이 코드 저 코드 넘나들면서 시간을 투자해야 한다. 어쩌면 개발자 몇 명이 더 달라 붙어서 해결해야 할 수도 있다.

하지만 TDD를 사용한 코드는 어떠한가? 이미 코드 작성과 함께 쌓아진 테스트 코드들이 한 가득 쌓여있다. 기능 추가를 해보고 사이드 이펙트를 찾기 위해서 그저 테스트를 돌려보면 된다. 지금까지 작성해왔던 테스트 코드들이 앞으로 발생하는 유지보수 시간들을 극적으로 줄여준다. 그저 우리가 견뎌야 할 것은 코드를 작성하는 시간이 두 배가 걸리는 것이다. 이 두 배의 시간은 미래의 우리를 구해줄 것이다.

## 왜 어려운가?

- Testable code를 작성하는 것이 어렵다. === 제품이 실행했을 때 결과를 미리 설명할 수 있는가.
- 관심사의 분리가 어렵다. === 하나의 컴포넌트가 응집된 책임 가지게 되도록 만든다. (단일 책임 원리)

## How

빠르게 통과시키기 위해서 수단 방법을 가리지마라.
요구사항을 명확하게 하라.

## 좋은 테스트의 조건

"특정 수준의 신뢰를 보장하는 최소한의 테스트 코드만 작성한다" ==> TDD 창시자 켄트 백 왈

1. 실행 속도가 빨라야 한다.
   테스트의 실행 속도가 빠르다는 것은 코드를 수정할 때마다 빠른 피드백을 받을 수 있다는 의미이다. 이는 개발 속도를 빠르게 하고, 테스트를 더 자주 실행할 수 있도록 한다. 결과를 보기 위해 수십 분을 기다려야 하는 테스트는 개발 과정에서 거의 무용지물에 가까울 것이다.

2. 내부 구현 변경 시 깨지지 않아야 한다.
   이 말은 "인터페이스를 기준으로 테스트를 작성하라"거나 "구현 종속적인 테스트를 작성하지 말라"는 지침과 같은 맥락이라 볼 수 있다. 좀 더 넓은 관점에서는 테스트의 단위를 너무 작게 쪼개는 경우도 해당된다. 작은 리팩토링에도 테스트가 깨진다면 코드를 개선할 때 믿고 의지할 수 없을 뿐 아니라, 오히려 테스트를 수정하는 비용을 발생시켜 코드 개선을 방해하는 결과를 낳게 된다.

3. 버그를 검출할 수 있어야 한다.
   달리 표현하면 "잘못된 코드를 검증하는 테스트는 실패해야 한다"라고 할 수 있다. 테스트가 기대하는 결과를 구체적으로 명시하지 않거나 예상 가능한 시나리오를 모두 검증하지 않으면 제품 코드에 있는 버그를 발견하지 못할 수 있다. 또한 모의 객체(Mock)를 과하게 사용하면 의존성이 있는 객체의 동작이 바뀌어도 테스트 코드가 연결 과정에서의 버그를 전혀 검출하지 못하게 된다. 그러므로 테스트 명세는 구체적이어야 하며, 모의 객체의 사용은 최대한 지양하는 것이 좋다.

4. 테스트의 결과가 안정적이어야 한다.
   어제 성공했던 테스트가 오늘은 실패하거나, 특정 기기에서 성공했던 테스트가 다른 기기에서는 실패한다면 해당 테스트를 신뢰할 수 없을 것이다. 즉, 테스트는 외부 환경의 영향을 최소화해서 언제 어디서 실행해도 동일한 결과를 보장해야 한다. 이러한 외부 환경은 현재 시간, 현재 기기의 OS, 네트워크 상태 등을 포함하며, 직접 조작할 수 있도록 모의 객체나 별도의 도구를 활용해야만 한다.

5. 의도가 명확히 드러나야 한다.
   제품 코드의 가독성이 중요하다는 것은 이제 누구나 인정하는 사실이다. 좋은 품질의 코드는 "기계가 읽기 좋은" 코드가 아닌 "사람이 읽기 좋은" 코드이다. 테스트 코드도 품질을 높이기 위해 제품 코드와 동일한 기준을 갖고 관리해야 한다. 즉, 테스트 코드를 보고 한 눈에 어떤 내용을 테스트하는지를 파악할 수 있어야 한다. 그렇지 않으면 추후에 해당 코드를 수정하거나 제거하기가 어려워져서 관리 비용이 늘어나게 된다. 테스트 준비를 위한 장황한 코드가 반복해서 사용되거나 결과를 검증하는 코드가 불필요하게 복잡하다면 별도의 함수 또는 단언문을 만들어서 추상화시키는 것이 좋다.

## 프론트엔드에서 테스트 전략의 중요성

프론트엔드 코드는 그래픽 사용자 인터페이스(GUI)와 밀접하게 관계되어 있고 사용자의 다양한 실행 환경을 고려해야 하기 때문에 다른 플랫폼에서 사용되는 전략을 그대로 사용할 수 없다. 시각적 요소, 서버와의 통신, 사용자 인터페이스(UI)를 통한 입력 등을 각각 어떻게 테스트 해야 할 지 고민하며 자신만의 전략을 세워야 한다.

## 테스트 도구의 중요성

프론트엔드 테스트의 전략을 세울 때는 도구의 역할 또한 아주 중요하다. 글을 시작할 때 최신 테스트 도구를 언급한 것은 이러한 도구들이 더 효율적인 전략을 세울 수 있도록 도와주기 때문이다. 예를 들어 기존 E2E(End To End) 도구를 사용한 테스트는 사용자의 관점에서 테스트할 수 있어 내부 구현에 영향을 거의 받지 않는 반면, 테스트 코드가 복잡하고 실행이 느리며 결과가 안정적이지 않다는 단점이 있었다. 하지만 최신 E2E 도구인 Cypress를 사용하면 기존 E2E 테스트의 장점은 유지하면서도 직관적이고 빠르고 안정적인 테스트를 작성할 수 있다. 즉, 테스트 도구의 발전이 더 나은 테스트 전략을 세울 수 있도록 도와주는 것이다.

### CLEAN CODE

1. 한번 작성된 테스트 코드는 영원히 유지보수 해야 한다.
2. 내부 구현 사항을 테스트 X
3. 재사용성을 높이기 (테스트 유틸리티)
4. 배포용 코드와 철저히 분리
5. 테스트코드를 통한 문서화

각각 테스트마다 먼저 준비해야 하거나 마무리해야 할 것이 있다면, jest의
before [beforeEach, beforeAll]
after [afterEach, afterAll]
을 사용해서 구성한다.

## 좋은 테스트의 원칙 FIRST

Given, When, Then.

F Fast 느린것에 대한 의존성 낮추기 [파일, 데이터베이스, 네트워크]
I Isolated 최소한의 유닛으로 검증하기 [독립적이고, 집중적으로 유지]
R Repeatable 실행할 때마다 동일한 결과를 유지.
S Self-Validating 스스로 결과를 검증하기. 자동화를 통한 검증단계 (CI/CD)
T Timely 시기적절하게 테스트 코드 작성. [사용자에게 배포되기 이전에 테스트 코드 작성]

## 테스트의 범위 Right-BICEP

B Boundary conditions 모든 코너 케이스에 대해 테스트를 하기.
I Inverse relationship 역관계를 적용해서 결괏값을 확인.
C Cross-check 다른 수단을 이용해서 결괏값이 맞는지 확인.
ex) 추가된 과일 == 전체 과일 - 이전 과일의 갯수
E Error conditions 불행한 경로에 대해 우아하게 처리 하는가?
P Performance characteristics 성능 확인은 테스트를 통해 정확한 수치로 확인.

## 좋은 테스트의 조건 CORRECT

C Conformance 특정 포맷을 준수
O Ordering 순서 조건을 확인하기
R Range 숫자의 범위 [제한된 범위보다 크거나 작은 경우]
R Reference 외부 의존성의 여부, 특정한 조건의 유무 [-일때, -가 되었을 때, 어떤 특정한 상황일 때, 이런 동작을 한다.]
E Existence 값이 존재하지 않을 때 어떻게 동작?
C Cardinality 0-1-N 법칙에 따라 검증 [없을 때, 하나만 있을 때, 여러 개가 있을 때]
T Time 상대, 절대, 동시의 일들 [순서가 맞지 않은 경우, 소비한 시간, 지역 시간]
