const LSCS = function (arr) {
  let subArrSum = arr[0];
  let max = arr[0]; // 정답의 후보를 저장
  for (let i = 1; i < arr.length; i++) {
    // subArrSum는 바로 직전의 요소까지 검토했을 때 가장 연속합
    // 연속합에 추가로 검토하는 요소, 즉 arr[i]를 더하는 것보다
    // arr[i] 하나의 값이 더 큰 경우 (subArrSum가 음수일 경우)
    // subArrSum를 버리는 게 좋다.
    // 쭉 더해서 음수인 부분은 굳이 더할 필요가 없다.

    // 문제는 주어진 배열의 연속된 부분의 배열의 합을 구했을 때,
    // 가장 큰 값이 나올 수 있는 것을 고르는 것이다.
    // 배열에 들어오는 수가 음수가 없다면 모든 배열을 더하는 것이 가장 큰 값이 될 것이다.
    // [1,2,3] ==> [1] [1,2] [1,2,3] [2] [2,3] [3] 이 숫자들 중 당연히
    // 음수가 없으니 모든 배열을 더하는 것이 가장 큰 값이 될 것이다.
    // 음수가 있다면? [1,2,3,-4] ==> [1] ... [-4]
    // 어떠한 방법을 써도 양수인 부분만 더하는 것이 가장 큰 값이 될 것이다.
    // 그렇다면 이런 경우는 어떠한 가? [1,2,-4,100] 이라면
    // 모든 배열을 더한 값은 99이다. 이런 경우엔 가장 큰 값인 100 혼자서 쓰는 것이
    // 1 큰 값이기 때문에 앞의 배열을 모두 더할 이유가 없다.

    // 이러한 경우들을 다 따져봤을 때 가장 일반적으로 음수가 없다면 모두 더하는 것이 가장 큰 값이고,
    // 음수가 있다면 따져봐야 할 것들이 많다. 그렇다면 문제를 해결하기 위해서 변수를 두가지 선언했다.
    // max와 subArrSum 둘 다 처음엔 arr[0]번째 값을 가질 것이고 2번 변수만이 이후에 인덱스 값들을
    // 더할 것인데, 음수가 있다면 아예 버리는 방향으로 갈 것이기 때문에 Math.max 메서드를 이용한다.
    // 다시 한 번 생각을 해야한다. 내가 찾는 것은 배열의 연속된 부분의 배열의 합이다. 연속된 배열만을 찾아야한다.
    // [1, -2, 3]에서 [1,3]은 할 수가 없다. 연속되지 않았다. 할거면 [1, -2, 3]아니면 [3]을 해야한다.

    // 그래서 변수를 두 가지 사용한 것이다. 첫 번째 선언한 변수 max는 기억을 하기 위함이다.
    // [1, 2, 3, -4, 1]는 모든 배열의 합이 3이다 이건 1,2,3까지만 더하니만 못한다.
    // 1번 변수는 그러한 점을 기억한다. 3까지 더했을 때, 6이 나오고 -4를 더하면 2. 2보단 6이 크니 6을 더 큰 숫자로 잡는다.
    // 이건 자연스럽게 [1,2,3]까지만 배열의 합을 쓰겠다는 의미이다. 이후에 값을 더했을 때 6보다 크면 음수를 감안하더라도
    // 더 큰 숫자를 가지는 배열의 인덱스까지의 합을 찾아줄 것이다.
    subArrSum = Math.max(subArrSum + arr[i], arr[i]);
    max = Math.max(max, subArrSum);
  }

  return max;
};
